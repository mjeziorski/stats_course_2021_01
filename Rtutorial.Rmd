---
title: "R tutorial"
author: "Michael C. Jeziorski"
date: "13 March 2019"
output:
  html_document: 
    toc: yes
    toc_depth: 2
    toc_float: 
      collapsed: no
    theme: cerulean
    df_print: kable
---
<style type="text/css">

code.r{ /* Code block */
    font-size: 12px;
    font-family-monospace: Monaco;
}

</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = "markup")
library(tidyverse)
```


# Introduction  <img style="float: right;" src="images/Rlogo.jpg">

### What is R?

R is a programming language widely used by scientists to organize, analyze, and visualize data.  It is free and open source, and many packages have been developed to allow researchers to work with particular types of data.

### Why does R have such an unhelpful name?

R is derived from the language S, which also has an unhelpful name that was created by people who never expected search engines to be important.  R was developed by Ross Ihaka and Robert Gentleman, so you can guess why they used the name R.  (Fortunately, it is not that difficult to use Google to find help with R.)

### Why should I learn R?

R is designed to be user-friendly to researchers who have relatively little programming experience.  Along with Python, R is the language of choice in the biological sciences, and a great number of analysis packages have been written for researchers.

### Does R replace the Linux commands we learned earlier in the course?

Linux is the best way to handle huge datafiles like the raw files generated by next-generation sequencing, processing of which requires intensive CPU usage, and familiarity with Linux commands is always useful for a data scientist.  However, R complements Linux well and is easier to use.  You will often do initial processing of a dataset in Linux and then move it to R for further analysis and visualization.

### I already use Excel for my data.  Can I just keep using that?

Excel is a convenient and user-friendly way to work with data, but it was not developed with scientists in mind and has many limitations.  Excel can also be risky because of its default settings; for example, gene names like OCT2 are often formatted as dates, causing errors in published data.  If you are working with a table that has a few entries or a few hundred, you may continue to find Excel useful.  Once a dataset reaches a larger size, R becomes a much better option to handle the data, and its visualization tools are stronger than those of Excel.

### How do I use R?

R can be installed on a computer running Windows, MacOS, or Linux.  It is downloaded at no cost from the [Comprehensive R Archive Network (CRAN)](https://www.r-project.org/).  R can be run as a command-line program.  However, this course will use RStudio to run R.

### What is RStudio?

[RStudio](https://www.rstudio.com/) is an integrated development environment (IDE), a software package that works as an interface between R and the user to make R far more user-friendly and flexible.  In this course we will see the many benefits to using RStudio.  RStudio does not include R itself, so the two software packages must be downloaded and installed separately.

### Can data be transferred between R and other programs?

R is intended to be friendly with other programs, and there are packages that will allow you to import Excel files, text, .csv files, and many other filetypes, including those used in bioinformatics.  Data can be exported and images saved in standard file formats.  R packages for biologists facilitate interaction with GenBank, EMBL, and other databases.

### What is an R package?

The distribution of R you install on your computer is known as "base R", and it includes a set of commands to organize and visualize data.  These commands are useful but limited, and packages have been developed to expand on them.  Such packages can be installed and loaded within R to give the user a greater range of options.  Packages are particularly important in bioinformatics, and in many of the analyses in this course, we will start by loading packages that will facilitate how we work with R.

To install a package, use the command  
`install.packages("<package name>")`  
This needs to be done only once.

To load a package into the current working environment, use  
`library(<package name>)`  
This needs to be done each time you start a new session, and generally should be at the start of your script.

### What can be created with R?

* lists
* tables
* statistical analyses
* data repositories
* graphs
* reports  
* documents for publication  
* slideshow presentations  
* maps  
* web applications that users can interact with  

The tutorial you are reading was created in R using R Markdown.

### How does the instructor of this course use R?

* I always work with R inside RStudio.  
* For each new research project I create a new R project in RStudio, which allows me to keep different work separated and organized.  
* The [tidyverse](https://www.tidyverse.org/packages/) is a suite of packages created by the people behind RStudio that are designed to make R easier and more intuitive.  I use tidyverse instead of base R whenever possible.  
* When creating an object, I use names that are short, easy to read, consistent, and informative.  For readability, I use an underline character to separate words (`my_file`), while others may use `my-file` or `myFile`.
* I add informative comments to my code as much as possible to help me later, knowing how frustrating it is to not remember what I was doing a year ago.  
* I want my code to be easily read, so I use spaces and indentation in consistent ways.  
* I prefer open-source software to licensed and often expensive software.  

***

# RStudio  <img style="float: right;" src="images/RStudio-Logo-Blue-Gray-125.png">

## Advantages of RStudio

* Ease of use  
* Availability of information  
* Organization  
* Flexibility  
* Reproducibility

## RStudio layout

### Console pane
The console pane is where R code is executed and output is generated.  You can enter code directly in the console pane or compose it in the script pane and then run it.

### Script pane
The script pane contains code to be executed.  Code can be run line by line or an entire script can be run at once.  If you plan to run a line of code more than once, it is best to include it in a script, which can be saved and edited.  The script pane is also for R markdown or R notebook files and is where dataframes can be viewed.

### Environment pane
The environment pane shows the objects that are currently loaded in the working environment.  Each time you create a new object, that object appears in the environment pane with some details about its contents.  In addition to the environment window, a history tab shows the history of executed commands.

### File/plot/help pane
The fourth pane has several tabs.  One shows the files available in the current working directory.  Another tab displays plots and a third shows HTML output.  The packages tab shows packages available for use.  Finally, the help tab provides documentation for R commands.

***

# Basic R elements

## Pay close attention

* UPPERCASE vs. lowercase  
* Close every parenthesis: `( )`  
* A line of code can continue on the next line, but the second line should be indented  
* Do not overwrite a variable unless you are certain you want to  
* Use object names that are clear  
* R uses 1-based indexing: the first element of a vector or list is in position 1

## Comments
A comment in R code is preceded by a hashtag (#).  Any text on the line after that symbol will not be executed.  Comments are highly useful and strongly recommended for providing information about what your code is intended to do.  Your memory is not as good as you think it is, so leave notes for yourself and others!
```{r}
# This is 3 plus 3.
3 + 3  # A comment can be on the same line as code that is executed.
```

## Arithmetic
Arithmetic operations can be executed directly in the console.
```{r}
2 + 5
2 - 1
3 * 4
7 / 6
3 ^ 3
```
## Comparisons
```{r}
4 == 3  # Note that to compare if two things are equal, a double equal sign is used.
4 > 3   # greater than
4 >= 3  # greater than or equal to
4 < 3   # less than
4 <= 3  # less than or equal to
4 != 3  # not equal to
```
## Logical connectors
```{r}
4 > 3 & 4 < 3  # Is 4 greater than 3 AND 4 less than 3?
4 > 3 | 4 < 3  # Is 4 greater than 3 OR 4 less than 3?
```

## Creating objects
Objects are created in R using the assignment operator, made up of two characters together without a space, `<-`  
`object_name <- value` or `operation`  
The equal sign (`=`) can also be used, but is not recommended because it is used for other operations.  The name of an object can be made up of letters, numbers, and `-` or `_`, but must begin with a letter.  Names of functions like `mean` should not be used as names of objects.  All spelling in R is case-dependent, so "apple" and "Apple" are different words.  

While this operation shows the result in the console
```{r}
18 + 73
```
this operation stores the result in an object.
```{r}
sum1 <- 18 + 73
```
Arithmetic operations can be executed on objects that are numbers.
```{r}
sum1 + 45
sum1 * sum1
```

***

# Basic types of objects

## Atomic datatypes
The basic datatypes in R include:  
**integer**: `8`, `4`, `23`  
**numeric** or **double**: `9.2`, `0.888`  
**character**: `"Mexico"`, `"sol"`, `"luna"` (always within either double or single quotation marks)  
**factor**: `"control"`, `"treatment"` (like character, but with defined levels)  
**logical**: `TRUE`, `FALSE`  (spelled out in all caps, no quotation marks)  
**complex**: `3 + 4i`

Special values:  
**missing value**: `NA`  
**infinity**: `Inf`  
**not a number**: `NaN`

## Values
An object can contain a single value, which is more accurately a vector of length 1.
```{r}
val1 <- 8
val2 <- "yellow"
val3 <- TRUE
```
The contents of an object can be seen by entering its name into the console.
```{r, eval = TRUE, echo = TRUE}
val1
```
The class, or datatype, of an object can be viewed using `class()`.
```{r}
class(val1)
class(val2)
class(val3)
```
An object can also store the result of an operation.
```{r}
val4 <- 9 + 13
val4
```
An object can be on both sides of the operation and will be overwritten with the new value.  This can be both convenient and dangerous because the previous value is erased.
```{r}
val4
val4 <- val4 + 5
val4
```
For operations to work, the datatypes need to be compatible.
```{r}
# val1 + 5  this will work because val1 is an integer
# val2 + 5  this will cause an error because val2 is a character object
```
R will make logical assumptions about datatypes.  Values can be coerced to another type.
```{r}
val1
as.character(val1)
```

## Vectors
An object can also be a vector of more than one value.  Combining two or more values is  done by using the `c()` command.
```{r}
# A sequence of numbers can be generated by using :
vec1 <- 1:40
vec1
# Other vectors can be made using the c() command to combine multiple values.
vec2 <- c(1.3, 2.9, 6.6, 3.0)
vec2
```
Elements in a vector can be named.
```{r}
vec3 <- c(a = "apple", b = "orange", c = "mango", d = "banana", e = "guayaba")
vec3
```
Values in a vector must be of the same type.  If values are of different types, R will coerce them to be the same type.  If R cannot coerce, it will replace the value with `NA`.
```{r}
vec4 <- c(1, "blue", 9)
vec4
```
An empty vector can be defined using the `vector()` function.
```{r}
vec5 <- vector("numeric", length = 10)
vec5
```
If a vector contains integers or numeric data, arithmetic operations can be executed on it.
```{r}
vec1 / 4
```
Functions in R can also work on vectors.
```{r}
mean(vec1)
sum(vec1)
```
Logical operations can work on vectors.
```{r}
vec2
vec2 > 3
vec2 >= 3
```
An element of a vector is extracted using the position number of the element inside single brackets: `[ ]`.  Consecutive elements are extracted by using the start and end position separated by `:` .
```{r}
vec3[2]
vec3[2:5]
```
A vector can also be subsetted by using a logical operation, extracting the elements for which the condition is `TRUE`.
```{r}
vec2 < 4
vec2[vec2 < 4]
```
## Lists
Unlike vectors or matrices, lists can contain different datatypes.  Lists can even contain other lists.  As such, they can have a complex structure.
```{r}
list1 <- list("a", 1, 6.3)
list1
```
Notice the more separated organization of lists.
```{r}
list2 <- list(18, list1, c("G", "A", "T", "C"))
list2
```
Due to their complex structure, lists are subsetted differently from vectors.  Single brackets will extract elements as lists, while double brackets can extract elements as other datatypes.
```{r}
list2[1]         # extract the first element of list2 as a list
class(list2[1])
list2[[1]]       # extract the first element of list2 as a value
class(list2[[1]])
list2[3]         # extract the third element of list2 as a list
list2[[3]]       # extract the third element of list2 as a vector
list2[[3]][1:2]  # extract a subset of the third element
```

## Matrices
Matrices are two-dimensional sets of data consisting of columns and rows in which all of the values are of a single type (e.g. numeric).  Although matrices are useful in R, due to time constraints we will focus on dataframes, which are both more complicated and more widely used.

## Dataframes
Like matrices, dataframes are datasets with rows and columns.  Unlike matrices, dataframes can have multiple datatypes such as integer and character, although every column has a defined datatype.  As such, a dataframe most closely resembles data in an Excel spreadsheet, although one that is perfectly rectangular.  Because dataframes can contain different datatypes, they are a special kind of list, a list of vectors (columns) in which each vector has the same length.
```{r}
df1 <- data.frame(x = 1:3, y = c("a", "b", "c"), z = c(TRUE, TRUE, FALSE))
df1
```
Because dataframe columns must all be of the same length, missing data will be replaced by `NA`.
```{r}
dim(df1)  # to see the dimensions of a dataframe (rows, columns)
str(df1)  # to see details about the columns of a dataframe
summary(df1)  # to get some summary statistics for the columns
```
Dataframes can be subset in various ways.  When using numbers to subset the dataframe, the first number is the row and the second the column.
```{r}
df1$x     # extract the column named "x" from df1 as a vector
df1[1, ]  # extract the first row from df1 as a dataframe
df1[, 3]  # extract the third column from df1
df1[2, 3] # extract the value in the second row, third column
df1[df1$x == 2, ]  # extract the row where x = 2
df1[df1$z == TRUE, ]  # extract the rows where z = TRUE
```
The column names can be seen or modified using `colnames()`.
```{r}
colnames(df1)
colnames(df1) <- c("a", "b", "c")
df1
df1$x    # no longer works due to renaming!
```
Values within a dataframe can be overwritten.
```{r}
df1
df1[2, 3] <- NA
df1
```

***

# Functions

R has a number of built-in functions, while other functions are contained within packages.  In addition, users can create their own functions.  Functions are composed of the function name followed by parentheses in which arguments are provided, either mandatory or optional.  Some functions can work without arguments.  For example, the following function shows the current date and time:
```{r eval = FALSE}
date()
```
An example of a function that requires an argument is `mean()`.  If we look at the help page for `mean()`, the structure of the command is:  
`mean(x, trim = 0, na.rm = FALSE, ...)`  
`x` is a mandatory object, the data for which the mean is calculated.  The remaining arguments are optional and have their default values shown.  We do not need to define them unless the default value is not desired.
```{r}
sample1 <- c(8, 12, 5, 13, 7)
mean(sample1)
# If the vector contains NA values, mean() returns NA.
sample2 <- c(8, 12, 5, 13, 7, NA)
mean(sample2)
# We can define the na.rm argument (remove NA) to ignore NA values.
mean(sample2, na.rm = TRUE)
```
User-defined functions are created using the `function()` command and curly braces `{}`.  If we want to write a function to calculate the length of the hypotenuse of a right triangle given the lengths of the two sides, the syntax is:
```{r}
hyp <- function(side1, side2) {
      sqrt((side1 ^ 2) + (side2 ^ 2))
}
hyp(3, 4)
hyp(5, 12)

```
`hyp(12)` returns an error because the function requires two arguments.

***

# The tidyverse package suite  <img style="float: right;" src="images/tidyverse-200x231.png">
* readr - to read in two-dimensional data  
* tidyr - for data organization  
* dplyr - for data manipulation  
* tibble - a modified approach to dataframes  
* stringr - to work with character strings  
* ggplot2 - for graphics  
* several other packages that integrate well with the above

We will work with dplyr commands to manipulate data and ggplot2 to visualize it.  We can load each package separately, but loading the tidyverse is easier.
```{r message = FALSE}
library(tidyverse)
```
The tidyverse works on the premise of "tidy data".  For a dataframe, tidy data means that each row is an observation and each column a variable.  A common challenge we face in data science is untidy data: inconsistent values, incorrect datatypes, `NA` values in many cells.  Much of the work with such data is in cleaning it up for downstream analysis.

R provides a variety of preloaded datasets for users to practice with; a list can be seen by typing `data()` into the console.  We will be using the `mtcars` dataset that contains data from *Motor Trend* magazine in 1974 for 32 different models of cars, and is a useful dataset to manipulate and visualize.

# dplyr functions
* `%>%` - the pipe operator, similar to `|` in Linux
* `select` - choose columns  
* `filter` - choose rows based on conditions  
* `arrange` - sort rows based on column values  
* `mutate` - convert data in an existing column into new data in a new column  
* `summarize` - provide summary data for a column  
* `group_by` - group data based on a variable; often used with summarize

We have several ways to get an idea of the structure and contents of a dataset.
```{r}
head(mtcars)       # to see the first six lines
str(mtcars)        # to see the structure, including dimensions
summary(mtcars)    # to see summary statistics of each column
glimpse(mtcars)    # this is the dplyr version of str()
```
## Pipe operator
One benefit of dplyr is the use of the pipe operator `%>%`, which is possible because the dplyr functions integrate well with each other.  As in Linux, the pipe tells R to treat the output from the previous command as input to the next command.  We will first examine some of the dplyr functions, then see how they can be linked together.

## `mutate`
The `mutate` function allows us to create new data columns from existing columns.  If we want to convert mpg (miles per gallon) to kilometers per liter, we can add a data column.  The syntax is  
`mutate(df, new_column = function(column))`
```{r}
mutate(mtcars, kmpl = mpg * 0.425)
```
Another use of `mutate` can address the difference between the output of base R commands and dplyr commands above.  The mtcars dataframe uses the names of the cars as row names.  This practice is discouraged by dplyr, so the output of dplyr commands lacks the car names.  We can resolve this issue by making a new dataframe with the names as a column.  The `mutate` function allows us to do this.
```{r}
mtcars_new <- mutate(mtcars, cars = rownames(mtcars))
head(mtcars_new)
```
## `select`
The `select` function allows us to select columns by name or position.  The syntax is  
`select(df, column_name(s))`  
where `df` is the dataframe.  Columns can be selected by name or by position number; this is a quick way to reorder the columns as well.  If we want to select column 6, 9, and 1-3, `select()` offers two ways.
```{r}
select(mtcars, 6, 9, 1:3)           # dplyr
select(mtcars, wt, am, mpg:disp)    # dplyr; often better because columns are named
```
## `filter`
The `filter` function filters rows based on criteria.
```{r}
filter(mtcars, cyl == 4)                     # dplyr
filter(mtcars, cyl == 4, am == 1, mpg > 25)  # filter based on multiple columns
```
If we want to define multiple criteria for one column, we can do so using the `%in%` operator.  The following returns all cars with either 4 or 8 cylinders.
```{r}
filter(mtcars, cyl %in% c(4, 8))
```
## `arrange`
The `arrange` function sorts the table based on one or more columns.  Use `desc()` to sort in descending order.  This replaces `sort()` in base R.  
`arrange(df, column, optional_second_column)`
```{r}
arrange(mtcars, desc(mpg))          # sort by mpg in descending order
arrange(mtcars, cyl, desc(mpg))     # sort by cyl, then mpg in descending order
```

## `group_by` and `summarize`
These two commands are often used together, and will be our first look at how the pipe operator can be used to chain commands.  `group_by` will separate the data into groups based on a column, and `summarize` can then perform operations on each group.

For example, `group_by` and `summarize` can be used together to generate mean mpg for cars of 4, 6, and 8 cylinders.
```{r}
group_by(mtcars, cyl) %>%               # group data by number of cylinders
      summarize(mean_mpg = mean(mpg))   # THEN find the mean mpg for each group
```
The pipe operator tells R to take the result of the `group_by` command as the input to the summarize command.  We can even use the dataframe as the initial input to the pipe, allowing functions to be simpler.
```{r}
mtcars %>%
      group_by(cyl) %>%               
      summarize(mean_mpg = mean(mpg), mean_hp = mean(hp))   
```
Piping functions together can be quite powerful.  Suppose we wanted to start with the original dataset and print out only the names and mpg of all 4-cylinder cars in descending order.  In base R, this would potentially involve creating several intermediate objects: a table with only 4-cylinder cars, then a sorted table, then selecting the columns.  dplyr allows us to do the same task with a single command using pipes, so intermediate objects do not need to be created.  We do not even have to create the `mtcars_new` dataset to get the desired output.
```{r}
mtcars %>%                                 # start with the original dataset
      mutate(cars = rownames(mtcars)) %>%  # THEN convert the row names to a column
      filter(cyl == 4) %>%                 # THEN filter the models with 4 cylinders
      arrange(desc(mpg)) %>%               # THEN sort by mpg, largest to smallest
      select(cars, mpg)                    # THEN show only the names and mpg
```
Now if we want to do the same for 8-cylinder cars, we simply change one number in the command.  No extra objects are being created. If the output is what we want, we can modify the command to assign the output to an object.
```{r}
mtcars %>%                                            # check output in console
      mutate(cars = rownames(mtcars)) %>%
      filter(cyl == 8) %>%                   
      arrange(desc(mpg)) %>%              
      select(cars, mpg)               
mtcars_8_cyl <- mtcars %>%                            # save output to object
      mutate(cars = rownames(mtcars)) %>%
      filter(cyl == 8) %>%                   
      arrange(desc(mpg)) %>%              
      select(cars, mpg)               
```

***

# Visualizing data with ggplot2  <img style="float: right;" src="images/ggplot2-200x232.png">
Another benefit of the tidyverse is that dplyr functions work well with ggplot2, the tidyverse graphing package.  The gg stands for "grammar of graphics", and ggplot2 is built on concepts of data visualization that allow a great number of possibilities.  Furthermore, the output of ggplot2 commands can be saved as objects, allowing them to be easily modified.

In ggplot2, we start by defining the "aesthetics", which are graph features on which we can map variables.  The most basic aesthetics are the x and y axes.  In the first line the dataset and aesthetics are defined, and then visualization options are added using the `+` operator.  For a scatterplot we use `geom_point()`; `geom` refers to the type of visualization layer.
```{r}
ggplot(mtcars, aes(x = hp, y = mpg)) +
      geom_point()
```

The graph is quite simple, but we can make it more interesting by adding aesthetics.  We will color the points by number of cylinders (`cyl`).
```{r}
ggplot(mtcars, aes(x = hp, y = mpg, color = cyl)) +
      geom_point()
```

The graph looks strange because ggplot is treating `cyl` as a continuous variable.  We know it to be discrete; no car has a fraction of a cylinder.  We can tell ggplot to treat the `cyl` variable as a factor with discrete levels using `as.factor()`.
```{r}
ggplot(mtcars, aes(x = hp, y = mpg, color = as.factor(cyl))) +
      geom_point()
```

We can keep adding aesthetics.  Engine displacement (`disp`) can be mapped to point size.
```{r}
ggplot(mtcars, aes(x = hp, y = mpg, color = as.factor(cyl), size = disp)) +
      geom_point()
```

Axis labels, legend, and other features can be customized.  For example, points can be made more transparent using the `alpha` argument to `geom_point`.
```{r}
ggplot(mtcars, aes(x = hp, y = mpg, color = as.factor(cyl), size = disp)) +
      geom_point(alpha = 0.5) +
      labs(x = "Horsepower", y = "Miles per gallon", 
           title = "Horsepower vs. fuel effiency for 1974 cars", 
           color = "cylinders", size = "displacement")
```

As we make the plot look better, we can save it as an object, then work with that object.
```{r}
mygraph <- ggplot(mtcars, 
                  aes(x = hp, y = mpg, color = as.factor(cyl), size = disp)) +
      geom_point() +
      labs(x = "Horsepower", y = "Miles per gallon", 
           title = "Horsepower vs. fuel effiency for 1974 cars", 
           color = "cylinders", size = "displacement")
# add a regression line
mygraph +
      geom_smooth(method = "lm", color = "orange", se = FALSE)
```

We can pipe using the dplyr `%>%` operator straight into ggplot, meaning we can easily graph a subset of our data.  For example, we can filter to view only American-made cars, defined by the variable `am == 0`.  
```{r}
# am == 1 denotes "foreign" (non-American) cars
mtcars %>%
      filter(am == 1) %>%
      ggplot(aes(x = hp, y = mpg, color = as.factor(cyl), size = disp)) +
      geom_point()
```

If the default settings are not appealing, we have many formatting options, including preset themes.
```{r}
mygraph +
      geom_smooth(method = "lm", color = "orange", se = FALSE) +
      theme_classic()
```

Two plots side by side, separated into American and "foreign" cars.
```{r}
mygraph +
      facet_grid(. ~ am)   # this creates a plot for each level of am
```

What do these graphs tell us about cars built in the United States vs. those built in other countries in 1974?